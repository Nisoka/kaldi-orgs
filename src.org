* gmm-init-mono.cc
  Vector<BaseFloat> glob_inv_var(dim);
  # 39 dim Vector inv_var 转置的对角协方差
  Vector<BaseFloat> glob_mean(dim); 
  Vecotr.Set(1.0);
  # (Set all members of Vector to the value)
  # 39 dim Vector mean
  
  Vector<double> var_stats(dim);
  Vector<double> mean_stats(dim);
  # var mean统计信息
  SequentialDoubleMatrixReader feat_reader(train_feats);
  # feat_reader 读取训练用feats
  
  foreach key_feats
      feareach feat_in_key
          count += 1.0
          var_stats.AddVec2(1.0, mat.Row(i));
          mean_stats.AddVec(1.0, mat.Row(i));
  
  var_stats.Scale(1.0/count);
  mean_stats.Scale(1.0/count);
  var_stats.AddVec2(-1.0, mean_stats);

  # (
  #  mean = sum{v_x} / cnt;
  #  var = sum{v_x^2}/cnt - mean^2
  # )

  var_stats.InvertElements();
  # 协方差转置 方便以后计算.
  glob_inv_var.CopyFromVec(var_stats);
  glob_mean.CopyFromVec(mean_stats);
  # 至此得到了 转置协方差 均值向量

  
  HmmTopology topo;
  bool binary_in;
  # 读取拓扑文件
  Input ki(topo_filename, &binary_in);
  topo.Read(ki.Stream(), binary_in);
  # vector<int32> 读取得到topo文件中所有的音素
  const std::vector<int32> &phones = topo.GetPhones();
  # 构造vector向量, 具有 1+phones.back()个元素 并全部初始化为0.
  std::vector<int32> phone2num_pdf_classes (1+phones.back());
  
  # 赋值 phone2num_pdf_class 某个音素phone对应的pdf-class? 不是应该state对应么？
  for (size_t i = 0; i < phones.size(); i++)
      phone2num_pdf_classes[phones[i]] = topo.NumPdfClasses(phones[i]);
      


  # 构建 状态绑定决策树, shared_phones 音素共享文件, 
  # 根据音素 状态拓扑结构中状态的最大pdf列表 以及所有共享音素 构建决策树.
  # 具体需要看完整个单音素训练过程 在看 kaldi中的决策树构建才行.
  *ContextDependency *ctx_dep = NULL;*
  ctx_dep = MonophoneContextDependencyShared(shared_phones, phone2num_pdf_classes);

  # 某个状态对应的GMM模型 - 即pdf-class的原理模型。
  DiagGmm gmm; 

  # AmDiagGmm 保存所有音素所有状态的gmm。
  AmDiagGmm am_gmm;
  for (int i = 0; i < num_pdfs; i++)
    am_gmm.AddPdf(gmm);


  # 根据状态决策树 以及 基本topo结构构建TransitonModel*
  *TrdansitionModel trans_model(*ctx_dep, topo);*

  {
    Output ko(model_filename, binary);
    # 这里的意思是 TransitionModel 并没有保存 am_gmm观测生成概率呢?
    trans_model.Write(ko.Stream(), binary);
    am_gmm.Write(ko.Stream(), binary);
  }



** TransitonModel construct
   1 构建tuples  transition-state (phone, state, pdf-id, pdf-id)
   2 state2tid  tid2state tid2pdf-id
   3 probs
   
   
***   ComputeTuples(ctx_dep) ComputeTuplesIsHmm()

     void TransitionModel::ComputeTuplesIsHmm(const ContextDependencyInterface &ctx_dep);
       # 获得topo结构里所有音素
       const std::vector<int32> &phones = topo_.GetPhones();
       std::vector<int32> num_pdf_classes;
       # 所有音素中所有状态的的最大pdf-class (某个音素有多个状态 每个状态有一个pdf-class 一般是音素内的状态index 0 1 2)
       # 结果num_pdf_classes 保存的是每个音素的 状态数.
       for (size_t i = 0; i < phones.size(); i++)
         *num_pdf_classes[phones[i]] = topo_.NumPdfClasses(phones[i]);*
       
       # this is the case for normal models. but not fot chain models
       #     对    的                  向量                         的 向量
       # <phone,pdf-class>某个state   多个相同pdf-class的state       所有的state
       std::vector<std::vector<std::pair<int32, int32> > > pdf_info;

       # 从决策树中取出 对应音素的pdf-info 每个音素 是< vector<pari<> > >
       # pdf-info 就是pdf-id (phone, pdf-class) 可以索引的pdf信息数组.
       *ctx_dep.GetPdfInfo(phones, num_pdf_classes, &pdf_info);*
       # 类似于pdf-info 可以用pdf-id 索引得到所有HMM状态. 因为状态绑定???是的因为pdf-class可以相同, 这样表示绑定
       std::map<std::pair<int32, int32>, std::vector<int32> > to_hmm_state_list;

       for (size_t i = 0; i < phones.size(); i++) {  // setting up to_hmm_state_list.
         int32 phone = phones[i];
         # 获得音素的 topologyEntry结构
         const HmmTopology::TopologyEntry &entry = topo_.TopologyForPhone(phone);
         # entry保存的是一系列状态, 就是遍历 音素phone 内状态
         for (int32 j = 0; j < static_cast<int32>(entry.size()); j++) {  // for each state...
           # 获得音素的 pdf-class
           int32 pdf_class = entry[j].forward_pdf_class;
           if (pdf_class != kNoPdf) {
             # 用 <phone, pdf-class> 进行索引, j 保存的是phone内状态号index, 
             *to_hmm_state_list[std::make_pair(phone, pdf_class)].push_back(j);*
           }
         }
       }


   # pdf-id 可以被多个 不同音素的不同pdf-class 共享.
   # pdf-class又可以由同一个音素的不同 HMM-State 共享.

   # 遍历所有pdf-id
   for (int32 pdf = 0; pdf < static_cast<int32>(pdf_info.size()); pdf++) {
     # 某个pdf-id 可能包含的多个共享pdf-class (phone, pdf-class). j
     for (size_t j = 0; j < pdf_info[pdf].size(); j++) {
       int32 phone = pdf_info[pdf][j].first,
             pdf_class = pdf_info[pdf][j].second;

       # state_vec 是可能发出该pdf_class的 phone内 多个HMM-state数组
       const std::vector<int32> &state_vec = to_hmm_state_list[std::make_pair(phone, pdf_class)];

       for (size_t k = 0; k < state_vec.size(); k++) {
         int32 hmm_state = state_vec[k];
         # 这样tuples_ 不会重复么？？？ 
         # 不会因为上面遍历的是 phone, pdf-class ，所有以phone,pdf-class 索引得到的状态都加入到tuples_里面了.
         *tuples_.push_back(Tuple(phone, hmm_state, pdf, pdf));*
       }
     }
   }

   num-pdf-class 每个音素含有的 pdf-class (绑定状态的共享pdf-index)
   pdf-info   vector< vector< pari<phone, pdf-class> > >
       由pdf-id 索引的, 向量内每个元素 每个Phone 包含的所有 pdf-class.
   to_hmm_state_list 
       保存元素是  以 phone, pdf-class 为观测生成函数的 所有的状态 (所有被绑定的状态)
   tuples  Tuple(phone, hmm_state, pdf, pdf)
       所有的 phone,state,pdf-id .
       
***   ComputeDerived()
   state2id_.resize(tuples_.size()+2);  // indexed by transition-state  --- (phone, state, pdf-id, pdf-id)  

   int32 cur_transition_id = 1;

   num_pdfs_ = 0;

   # tuples  transition-state 实际就是 所有状态的所有状态
   for (int32 tstate = 1;
       tstate <= static_cast<int32>(tuples_.size()+1);  // not a typo.
       tstate++) {
     # state2id_[] 保存对应transition-state 对应的 多个transition的第一个transition-id
     *state2id_[tstate] = cur_transition_id;*

     if (static_cast<size_t>(tstate) <= tuples_.size()) {

       int32 
       phone = tuples_[tstate-1].phone,
       hmm_state = tuples_[tstate-1].hmm_state,
       forward_pdf = tuples_[tstate-1].forward_pdf,
       self_loop_pdf = tuples_[tstate-1].self_loop_pdf;
       # pdf-id
       num_pdfs_ = std::max(num_pdfs_, 1 + forward_pdf);
       num_pdfs_ = std::max(num_pdfs_, 1 + self_loop_pdf);
       # 该 transition-state 的 HMM-State.
       const HmmTopology::HmmState &state = topo_.TopologyForPhone(phone)[hmm_state];
       # 状态的所有转移.
       int32 my_num_ids = static_cast<int32>(state.transitions.size());
       # state2id_ 保存的是 状态对应的多个转移的第一个转移编号 
       *cur_transition_id += my_num_ids;  // # trans out of this state.*
     }
   }

   # state2id_ 的反向索引 tid -> (phone, state)
   id2state_.resize(cur_transition_id);   // cur_transition_id is #transition-ids+1.
   # 从transition-id  ---> pdf-id
   id2pdf_id_.resize(cur_transition_id);

   for (int32 tstate = 1; tstate <= static_cast<int32>(tuples_.size()); tstate++)
     for (int32 tid = state2id_[tstate]; tid < state2id_[tstate+1]; tid++) {
       id2state_[tid] = tstate;
       if (IsSelfLoop(tid))
         id2pdf_id_[tid] = tuples_[tstate-1].self_loop_pdf;
       else
         id2pdf_id_[tid] = tuples_[tstate-1].forward_pdf;
     }
   }

***   InitializeProbs()

   log_probs_.Resize(NumTransitionIds()+1);  // one-based array, zeroth element empty.
   
   for (int32 trans_id = 1; trans_id <= NumTransitionIds(); trans_id++) {

     # trans_state --- tuples (phone, state)
     int32 trans_state = id2state_[trans_id];
     # trans_index --- transition-id 在 某个trans_state 中的index
     int32 trans_index = trans_id - state2id_[trans_state]; 

     # 获得tuple
     const Tuple &tuple = tuples_[trans_state-1];
     # 获得phone的状态
     const HmmTopology::TopologyEntry &entry = topo_.TopologyForPhone(tuple.phone);
     # entry[state] 获得该状态 
     # entry[state].transitions[trans_index].second -- 转移概率.
     BaseFloat prob = entry[tuple.hmm_state].transitions[trans_index].second;
     
     #
     *log_probs_(trans_id) = Log(prob);*
   }
   ComputeDerivedOfProbs();
***   Check()






* compile-train-graphs.cc

    compile-train-graphs --read-disambig-syms=$lang/phones/disambig.int $dir/tree $dir/0.mdl  $lang/L.fst \
    "ark:sym2int.pl --map-oov $oov_sym -f 2- $lang/words.txt < $sdata/JOB/text|" \
    "ark:|gzip -c >$dir/fsts.JOB.gz" || exit 1;
    
    src/bin/compile-train-graphs.cc


    disambig_rxfilename ====  所有销岐符号
    std::string tree_rxfilename = exp/mono/tree
    std::string model_rxfilename = exp/mono/0.mdl
    std::string lex_rxfilename = lexcion.txt
    std::string transcript_rspecifier = data/mfcc/train/split4/JOB/text --- 中文标注
    std::string fsts_wspecifier =  exp/mono/fsts.JOB.gz    

    # tree
    ContextDependency ctx_dep;  // the tree.
    ReadKaldiObject(tree_rxfilename, &ctx_dep);

    # mdl
    TransitionModel trans_model;
    ReadKaldiObject(model_rxfilename, &trans_model);

    # need VectorFst because we will change it by adding subseq symbol.
    # ?????? 
    VectorFst<StdArc> *lex_fst = fst::ReadFstKaldi(lex_rxfilename);

    std::vector<int32> disambig_syms;

    # disambig_syms --- 保存销岐符号。
    if (disambig_rxfilename != "")
      if (!ReadIntegerVectorSimple(disambig_rxfilename, &disambig_syms))
        KALDI_ERR << "fstcomposecontext: Could not read disambiguation symbols from "
                  << disambig_rxfilename;

    # 将 tree mdl lexicon disambig options 都加入到trainGraph中.                  
    *TrainingGraphCompiler gc(trans_model, ctx_dep, lex_fst, disambig_syms, gopts);*

    lex_fst = NULL;  // we gave ownership to gc.

    # read 中文标注 -> transcript_reader
    SequentialInt32VectorReader transcript_reader(transcript_rspecifier);
    # 获得写描述符<VectorFstHolder>  fsts.JOB.gz
    TableWriter<fst::VectorFstHolder> fst_writer(fsts_wspecifier);

    int num_succeed = 0, num_fail = 0;
    

    *batch_size = 250;*
    if (batch_size == 1) {  // We treat batch_size of 1 as a special case in order

    } else {
      # key - transcript
      # uttid - utt_words
      std::vector<std::string> keys;
      std::vector<std::vector<int32> > transcripts;
      
      # 读取所有utt的 id 以及中文标注
      while (!transcript_reader.Done()) {
        keys.clear();
        transcripts.clear();

        # 一次读取 batch_size 的记录数 --- utt id + 中文标注
        for (; !transcript_reader.Done() &&
                static_cast<int32>(transcripts.size()) < batch_size;
            transcript_reader.Next()) {
          # keys - vector<uttid>
          keys.push_back(transcript_reader.Key());
          # transcript - vector<vector<wordid>>
          transcripts.push_back(transcript_reader.Value());
        }

        std::vector<fst::VectorFst<fst::StdArc>* > fsts;
        
        # 执行构图 word构图得到 每个utt的G.fst , 存入到 fsts中.
        if (!gc.CompileGraphsFromText(transcripts, &fsts)) {
          KALDI_ERR << "Not expecting CompileGraphs to fail.";
        }
        
        for (size_t i = 0; i < fsts.size(); i++) {
          # 判断构图正确性, 将 <uttid, fst> 写入fst_writer
          if (fsts[i]->Start() != fst::kNoStateId) {
            num_succeed++;
            fst_writer.Write(keys[i], *(fsts[i]));
          } else {
            KALDI_WARN << "Empty decoding graph for utterance "
                       << keys[i];
            num_fail++;
          }
        }
        DeletePointers(&fsts);
      }
    }


** CompileGraphsFromText(transcript, &fsts){
  using namespace fst;
  VectorFst<StdArc> word_fst;

***  MakeLinearAcceptor(transcript, &word_fst);
  # 构建线性图  根据transcript 构建
  312   typedef typename Arc::StateId StateId;
  313   typedef typename Arc::Weight Weight;
  314 
  315   ofst->DeleteStates();
  # 增加状态 作为初始状态
  316   StateId cur_state = ofst->AddState();
  317   ofst->SetStart(cur_state);

  # 根据labels 循环增加状态 next_state, 并构建状态转移弧 Arc
  318   for (size_t i = 0; i < labels.size(); i++) {
  319     StateId next_state = ofst->AddState();
  320     Arc arc(labels[i], labels[i], Weight::One(), next_state);
  321     ofst->AddArc(cur_state, arc);
  322     cur_state = next_state;
  323   }
  # 构建终止状态
  324   ofst->SetFinal(cur_state, Weight::One());

  return 
  
***  return CompileGraph(word_fst, out_fst);
  using namespace fst;

  VectorFst<StdArc> phone2word_fst;
  # TableCompose more efficient than compose.
  # lex_fst_ 是前面构造函数时候 获得的
  # phone2word_fst， 输出结果
  TableCompose(*lex_fst_, word_fst, &phone2word_fst, &lex_cache_);

  ContextFst<StdArc> *cfst = NULL;

  {  // make cfst [ it's expanded on the fly ]
    # needed to create context fst.
    const std::vector<int32> &phone_syms = trans_model_.GetPhones();  
    int32 subseq_symbol = phone_syms.back() + 1;
    if (!disambig_syms_.empty() && subseq_symbol <= disambig_syms_.back())
      subseq_symbol = 1 + disambig_syms_.back();

    cfst = new ContextFst<StdArc>(subseq_symbol,
                                  phone_syms,
                                  disambig_syms_,
                                  ctx_dep_.ContextWidth(),
                                  ctx_dep_.CentralPosition());
  }

  VectorFst<StdArc> ctx2word_fst;
  ComposeContextFst(*cfst, phone2word_fst, &ctx2word_fst);
  // ComposeContextFst is like Compose but faster for this particular Fst type.
  // [and doesn't expand too many arcs in the ContextFst.]

  KALDI_ASSERT(ctx2word_fst.Start() != kNoStateId);

  HTransducerConfig h_cfg;
  h_cfg.transition_scale = opts_.transition_scale;

  std::vector<int32> disambig_syms_h; // disambiguation symbols on
  // input side of H.
  VectorFst<StdArc> *H = GetHTransducer(cfst->ILabelInfo(),
                                        ctx_dep_,
                                        trans_model_,
                                        h_cfg,
                                        &disambig_syms_h);
  
  VectorFst<StdArc> &trans2word_fst = *out_fst;  // transition-id to word.
  TableCompose(*H, ctx2word_fst, &trans2word_fst);
  
  KALDI_ASSERT(trans2word_fst.Start() != kNoStateId);

  // Epsilon-removal and determinization combined. This will fail if not determinizable.
  DeterminizeStarInLog(&trans2word_fst);

  if (!disambig_syms_h.empty()) {
    RemoveSomeInputSymbols(disambig_syms_h, &trans2word_fst);
    // we elect not to remove epsilons after this phase, as it is
    // a little slow.
    if (opts_.rm_eps)
      RemoveEpsLocal(&trans2word_fst);
  }

  
  # Encoded minimization.
  MinimizeEncoded(&trans2word_fst);

  std::vector<int32> disambig;
  AddSelfLoops(trans_model_,
               disambig,
               opts_.self_loop_scale,
               opts_.reorder,
               &trans2word_fst);
}


* Others

  1 OpenFst --- StdArc Arc VectorFst
