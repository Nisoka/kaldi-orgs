* gmm-init-mono.cc
  Vector<BaseFloat> glob_inv_var(dim);
  # 39 dim Vector inv_var 转置的对角协方差
  Vector<BaseFloat> glob_mean(dim); 
  Vecotr.Set(1.0);
  # (Set all members of Vector to the value)
  # 39 dim Vector mean
  
  Vector<double> var_stats(dim);
  Vector<double> mean_stats(dim);
  # var mean统计信息
  SequentialDoubleMatrixReader feat_reader(train_feats);
  # feat_reader 读取训练用feats
  
  foreach key_feats
      feareach feat_in_key
          count += 1.0
          var_stats.AddVec2(1.0, mat.Row(i));
          mean_stats.AddVec(1.0, mat.Row(i));
  
  var_stats.Scale(1.0/count);
  mean_stats.Scale(1.0/count);
  var_stats.AddVec2(-1.0, mean_stats);

  # (
  #  mean = sum{v_x} / cnt;
  #  var = sum{v_x^2}/cnt - mean^2
  # )

  var_stats.InvertElements();
  # 协方差转置 方便以后计算.
  glob_inv_var.CopyFromVec(var_stats);
  glob_mean.CopyFromVec(mean_stats);
  # 至此得到了 转置协方差 均值向量

  
  HmmTopology topo;
  bool binary_in;
  # 读取拓扑文件
  Input ki(topo_filename, &binary_in);
  topo.Read(ki.Stream(), binary_in);
  # vector<int32> 读取得到topo文件中所有的音素
  const std::vector<int32> &phones = topo.GetPhones();
  # 构造vector向量, 具有 1+phones.back()个元素 并全部初始化为0.
  std::vector<int32> phone2num_pdf_classes (1+phones.back());
  
  # 赋值 phone2num_pdf_class 某个音素phone对应的pdf-class? 不是应该state对应么？
  for (size_t i = 0; i < phones.size(); i++)
      phone2num_pdf_classes[phones[i]] = topo.NumPdfClasses(phones[i]);
      


  # 构建 状态绑定决策树, shared_phones 音素共享文件, 
  # 根据音素 状态拓扑结构中状态的最大pdf列表 以及所有共享音素 构建决策树.
  # 具体需要看完整个单音素训练过程 在看 kaldi中的决策树构建才行.
  *ContextDependency *ctx_dep = NULL;*
  ctx_dep = MonophoneContextDependencyShared(shared_phones, phone2num_pdf_classes);

  # 某个状态对应的GMM模型 - 即pdf-class的原理模型。
  DiagGmm gmm; 

  # AmDiagGmm 保存所有音素所有状态的gmm。
  AmDiagGmm am_gmm;
  for (int i = 0; i < num_pdfs; i++)
    am_gmm.AddPdf(gmm);


  # 根据状态决策树 以及 基本topo结构构建TransitonModel*
  *TrdansitionModel trans_model(*ctx_dep, topo);*

  {
    Output ko(model_filename, binary);
    # 这里的意思是 TransitionModel 并没有保存 am_gmm观测生成概率呢?
    trans_model.Write(ko.Stream(), binary);
    am_gmm.Write(ko.Stream(), binary);
  }



* TransitonModel construct
  1 构建tuples  transition-state (phone, state, pdf-id, pdf-id)
  2 state2tid  tid2state tid2pdf-id
  3 probs
  
  
**   ComputeTuples(ctx_dep) ComputeTuplesIsHmm()

    void TransitionModel::ComputeTuplesIsHmm(const ContextDependencyInterface &ctx_dep);
      # 获得topo结构里所有音素
      const std::vector<int32> &phones = topo_.GetPhones();
      std::vector<int32> num_pdf_classes;
      # 所有音素中所有状态的的最大pdf-class (某个音素有多个状态 每个状态有一个pdf-class 一般是音素内的状态index 0 1 2)
      # 结果num_pdf_classes 保存的是每个音素的 状态数.
      for (size_t i = 0; i < phones.size(); i++)
        *num_pdf_classes[phones[i]] = topo_.NumPdfClasses(phones[i]);*
      
      # this is the case for normal models. but not fot chain models
      #     对    的                  向量                         的 向量
      # <phone,pdf-class>某个state   多个相同pdf-class的state       所有的state
      std::vector<std::vector<std::pair<int32, int32> > > pdf_info;

      # 从决策树中取出 对应音素的pdf-info 每个音素 是< vector<pari<> > >
      # pdf-info 就是pdf-id (phone, pdf-class) 可以索引的pdf信息数组.
      *ctx_dep.GetPdfInfo(phones, num_pdf_classes, &pdf_info);*
      # 类似于pdf-info 可以用pdf-id 索引得到所有HMM状态. 因为状态绑定???是的因为pdf-class可以相同, 这样表示绑定
      std::map<std::pair<int32, int32>, std::vector<int32> > to_hmm_state_list;

      for (size_t i = 0; i < phones.size(); i++) {  // setting up to_hmm_state_list.
        int32 phone = phones[i];
        # 获得音素的 topologyEntry结构
        const HmmTopology::TopologyEntry &entry = topo_.TopologyForPhone(phone);
        # entry保存的是一系列状态, 就是遍历 音素phone 内状态
        for (int32 j = 0; j < static_cast<int32>(entry.size()); j++) {  // for each state...
          # 获得音素的 pdf-class
          int32 pdf_class = entry[j].forward_pdf_class;
          if (pdf_class != kNoPdf) {
            # 用 <phone, pdf-class> 进行索引, j 保存的是phone内状态号index, 
            *to_hmm_state_list[std::make_pair(phone, pdf_class)].push_back(j);*
          }
        }
      }


  # pdf-id 可以被多个 不同音素的不同pdf-class 共享.
  # pdf-class又可以由同一个音素的不同 HMM-State 共享.

  # 遍历所有pdf-id
  for (int32 pdf = 0; pdf < static_cast<int32>(pdf_info.size()); pdf++) {
    # 某个pdf-id 可能包含的多个共享pdf-class (phone, pdf-class). j
    for (size_t j = 0; j < pdf_info[pdf].size(); j++) {
      int32 phone = pdf_info[pdf][j].first,
            pdf_class = pdf_info[pdf][j].second;

      # state_vec 是可能发出该pdf_class的 phone内 多个HMM-state数组
      const std::vector<int32> &state_vec = to_hmm_state_list[std::make_pair(phone, pdf_class)];

      for (size_t k = 0; k < state_vec.size(); k++) {
        int32 hmm_state = state_vec[k];
        # 这样tuples_ 不会重复么？？？ 
        # 不会因为上面遍历的是 phone, pdf-class ，所有以phone,pdf-class 索引得到的状态都加入到tuples_里面了.
        *tuples_.push_back(Tuple(phone, hmm_state, pdf, pdf));*
      }
    }
  }

  num-pdf-class 每个音素含有的 pdf-class (绑定状态的共享pdf-index)
  pdf-info   vector< vector< pari<phone, pdf-class> > >
      由pdf-id 索引的, 向量内每个元素 每个Phone 包含的所有 pdf-class.
  to_hmm_state_list 
      保存元素是  以 phone, pdf-class 为观测生成函数的 所有的状态 (所有被绑定的状态)
  tuples  Tuple(phone, hmm_state, pdf, pdf)
      所有的 phone,state,pdf-id .
      
**   ComputeDerived()
  state2id_.resize(tuples_.size()+2);  // indexed by transition-state  --- (phone, state, pdf-id, pdf-id)  

  int32 cur_transition_id = 1;

  num_pdfs_ = 0;

  # tuples  transition-state 实际就是 所有状态的所有状态
  for (int32 tstate = 1;
      tstate <= static_cast<int32>(tuples_.size()+1);  // not a typo.
      tstate++) {
    # state2id_[] 保存对应transition-state 对应的 多个transition的第一个transition-id
    *state2id_[tstate] = cur_transition_id;*

    if (static_cast<size_t>(tstate) <= tuples_.size()) {

      int32 
      phone = tuples_[tstate-1].phone,
      hmm_state = tuples_[tstate-1].hmm_state,
      forward_pdf = tuples_[tstate-1].forward_pdf,
      self_loop_pdf = tuples_[tstate-1].self_loop_pdf;
      # pdf-id
      num_pdfs_ = std::max(num_pdfs_, 1 + forward_pdf);
      num_pdfs_ = std::max(num_pdfs_, 1 + self_loop_pdf);
      # 该 transition-state 的 HMM-State.
      const HmmTopology::HmmState &state = topo_.TopologyForPhone(phone)[hmm_state];
      # 状态的所有转移.
      int32 my_num_ids = static_cast<int32>(state.transitions.size());
      # state2id_ 保存的是 状态对应的多个转移的第一个转移编号 
      *cur_transition_id += my_num_ids;  // # trans out of this state.*
    }
  }

  # state2id_ 的反向索引 tid -> (phone, state)
  id2state_.resize(cur_transition_id);   // cur_transition_id is #transition-ids+1.
  # 从transition-id  ---> pdf-id
  id2pdf_id_.resize(cur_transition_id);

  for (int32 tstate = 1; tstate <= static_cast<int32>(tuples_.size()); tstate++)
    for (int32 tid = state2id_[tstate]; tid < state2id_[tstate+1]; tid++) {
      id2state_[tid] = tstate;
      if (IsSelfLoop(tid))
        id2pdf_id_[tid] = tuples_[tstate-1].self_loop_pdf;
      else
        id2pdf_id_[tid] = tuples_[tstate-1].forward_pdf;
    }
  }

**   InitializeProbs()

  log_probs_.Resize(NumTransitionIds()+1);  // one-based array, zeroth element empty.
  
  for (int32 trans_id = 1; trans_id <= NumTransitionIds(); trans_id++) {

    # trans_state --- tuples (phone, state)
    int32 trans_state = id2state_[trans_id];
    # trans_index --- transition-id 在 某个trans_state 中的index
    int32 trans_index = trans_id - state2id_[trans_state]; 

    # 获得tuple
    const Tuple &tuple = tuples_[trans_state-1];
    # 获得phone的状态
    const HmmTopology::TopologyEntry &entry = topo_.TopologyForPhone(tuple.phone);
    # entry[state] 获得该状态 
    # entry[state].transitions[trans_index].second -- 转移概率.
    BaseFloat prob = entry[tuple.hmm_state].transitions[trans_index].second;
    
    #
    *log_probs_(trans_id) = Log(prob);*
  }
  ComputeDerivedOfProbs();
**   Check()


* compile-train-graphs.cc

    disambig_rxfilename ====  所有销岐符号
    std::string tree_rxfilename = exp/mono/tree
    std::string model_rxfilename = exp/mono/0.mdl
    std::string lex_rxfilename = lexcion.txt
    std::string transcript_rspecifier = data/mfcc/train/split4/JOB/text --- 中文标注
    std::string fsts_wspecifier =  exp/mono/fsts.JOB.gz    

    # tree
    ContextDependency ctx_dep;  // the tree.
    ReadKaldiObject(tree_rxfilename, &ctx_dep);

    # mdl
    TransitionModel trans_model;
    ReadKaldiObject(model_rxfilename, &trans_model);

    # need VectorFst because we will change it by adding subseq symbol.
    # ?????? 
    VectorFst<StdArc> *lex_fst = fst::ReadFstKaldi(lex_rxfilename);

    std::vector<int32> disambig_syms;

    # disambig_syms --- 保存销岐符号。
    if (disambig_rxfilename != "")
      if (!ReadIntegerVectorSimple(disambig_rxfilename, &disambig_syms))
        KALDI_ERR << "fstcomposecontext: Could not read disambiguation symbols from "
                  << disambig_rxfilename;

    # 将 tree mdl lexicon disambig options 都加入到trainGraph中.                  
    *TrainingGraphCompiler gc(trans_model, ctx_dep, lex_fst, disambig_syms, gopts);*

    lex_fst = NULL;  // we gave ownership to gc.

    # read 中文标注
    SequentialInt32VectorReader transcript_reader(transcript_rspecifier);
    # 获得写描述符  fsts.JOB.gz
    TableWriter<fst::VectorFstHolder> fst_writer(fsts_wspecifier);

    int num_succeed = 0, num_fail = 0;
    

    *batch_size = 250;*
    if (batch_size == 1) {  // We treat batch_size of 1 as a special case in order

    } else {
      std::vector<std::string> keys;
      std::vector<std::vector<int32> > transcripts;
      
      # 读取所有utt的 id 以及中文标注
      while (!transcript_reader.Done()) {
        keys.clear();
        transcripts.clear();

        # 一次读取 batch_size 的记录数 --- utt id + 中文标注
        for (; !transcript_reader.Done() &&
                static_cast<int32>(transcripts.size()) < batch_size;
            transcript_reader.Next()) {
          keys.push_back(transcript_reader.Key());
          transcripts.push_back(transcript_reader.Value());
        }

        std::vector<fst::VectorFst<fst::StdArc>* > fsts;
        
        # 执行构图 word构图得到 每个utt的G.fst , 存入到 fsts中.
        if (!gc.CompileGraphsFromText(transcripts, &fsts)) {
          KALDI_ERR << "Not expecting CompileGraphs to fail.";
        }
        
        for (size_t i = 0; i < fsts.size(); i++) {
          # 判断构图正确性, 将 <uttid, fst> 写入fst_writer
          if (fsts[i]->Start() != fst::kNoStateId) {
            num_succeed++;
            fst_writer.Write(keys[i], *(fsts[i]));
          } else {
            KALDI_WARN << "Empty decoding graph for utterance "
                       << keys[i];
            num_fail++;
          }
        }
        DeletePointers(&fsts);
      }
    }


