
steps/train_deltas.sh --boost-silence 1.25 --cmd "$train_cmd" \
2000 10000 data/mfcc/train data/lang exp/mono_ali exp/tri1 || exit 1;

# 决策树叶节点总数 2000 绑定状态数
numleaves = $1 
# 高斯总数   平均每个状态5个混合数??? 编译后看看
totgauss=$2
# mfcc/train/
data=$3
# lang/ 拓扑结构、发音词典、其他发音、所有词words.txt
lang=$4
# mono_ali 已对齐的单音素训练结果.
alidir=$5
# tri1 三音素结果 输出目录
dir=$6


acc-tree-stats --ci-phones=$ciphonelist $alidir/final.mdl "$feats" "ark:gunzip -c $alidir/ali.JOB.gz|" $dir/JOB.treeacc || exit 1;

sum-tree-stats $dir/treeacc $dir/*.treeacc 2>$dir/log/sum_tree_acc.log || exit 1;


* acc-tree-stats
  /** @brief Accumulate tree statistics for decision tree training. The
program reads in a feature archive, and the corresponding alignments,
and generates the sufficient statistics for the decision tree
creation. Context width and central phone position are used to
identify the contexts.Transition model is used as an input to identify
the PDF's and the phones.  */

int main(int argc, char *argv[]) {
  using namespace kaldi;
  typedef kaldi::int32 int32;
  try {
    const char *usage =
        "Accumulate statistics for phonetic-context tree building.\n"
        "Usage:  acc-tree-stats [options] <model-in> <features-rspecifier> <alignments-rspecifier> <tree-accs-out>\n"
        "e.g.: \n"

        # 输入 HMM-GMM模型   特征  对齐的状态序列   
        # 输出 计算统计量
        " acc-tree-stats 1.mdl scp:train.scp ark:1.ali 1.tacc\n";

    bool binary = true;
    # 计算 决策树需要的 统计信息 选项.
    AccumulateTreeStatsOptions opts;


    std::string
    model_filename = po.GetArg(1),
    feature_rspecifier = po.GetArg(2),
    # 对齐状态序列
    alignment_rspecifier = po.GetArg(3),
    accs_out_wxfilename = po.GetOptArg(4);


    # 统计 决策树统计信息
    AccumulateTreeStatsInfo acc_tree_stats_info(opts);

    # 转移模型
    TransitionModel trans_model;
    {
      bool binary;
      Input ki(model_filename, &binary);
      trans_model.Read(ki.Stream(), binary);
    }

    # 特征reader
    SequentialBaseFloatMatrixReader feature_reader(feature_rspecifier);
    # 对齐状态reader
    RandomAccessInt32VectorReader alignment_reader(alignment_rspecifier);

    # 绑定树 用的统计量 EventType -- <三音素, 状态>  某个确定状态
    #                   GaussClusterable             该状态对应的特征向量个数、特征向量累加、特征向量平方和累加.
    *std::map<EventType, GaussClusterable*> tree_stats;*
    int num_done = 0, num_no_alignment = 0, num_other_error = 0;
    # foreach utt
    for (; !feature_reader.Done(); feature_reader.Next()) {
      # utt feature
      std::string key = feature_reader.Key();
      # align states
      if (!alignment_reader.HasKey(key)) {
        num_no_alignment++;
      } else {
        # utt feature is mat (frame X 39)
        const Matrix<BaseFloat> &mat = feature_reader.Value();
        # vector<trans-ids>  对齐的转移id
        const std::vector<int32> &alignment = alignment_reader.Value(key);
        
        if (alignment.size() != mat.NumRows()) {
          KALDI_WARN << "Alignments has wrong size "<< (alignment.size())<<" vs. "<< (mat.NumRows());
          num_other_error++;
          continue;
        }

        # 根据统计模型、对齐的trans-ids、特征mat 以及统计用参数, 
        # 计算统计信息  --- > tree_stats
        AccumulateTreeStats(trans_model,
                            acc_tree_stats_info,
                            alignment,
                            mat,
                            &tree_stats);
        num_done++;
        if (num_done % 1000 == 0)
          KALDI_LOG << "Processed " << num_done << " utterances.";
      }
    }

    
    BuildTreeStatsType stats;  // vectorized form.

    # foreach state-stats？？？ 保存的和 刚刚计算没什么区别, 可能这里更好使用吧.
    for (std::map<EventType, GaussClusterable*>::const_iterator iter = tree_stats.begin();
         iter != tree_stats.end();
         ++iter) {
      
      stats.push_back(std::make_pair(iter->first, iter->second));
    }
    tree_stats.clear();
    
    # write 统计信息
    {
      Output ko(accs_out_wxfilename, binary);
      WriteBuildTreeStats(ko.Stream(), binary, stats);
    }

    DeleteBuildTreeStats(&stats);
}


**  AccumulateTreeStats 计算决策树构建需要的统计量

void AccumulateTreeStats(const TransitionModel &trans_model,
                         const AccumulateTreeStatsInfo &info,
                         const std::vector<int32> &alignment,
                         const Matrix<BaseFloat> &features,
                         std::map<EventType, GaussClusterable*> *stats) {

  std::vector<std::vector<int32> > split_alignment;
  # SplitToPhones 将utt 对齐trans-ids 根据对应的音素 进行split划分, 
  # 划分得到多个 Vector<音素- vector<状态id> > 
  # 将trans-ids 转化为 以phone为分割的 状态序列. 
  bool ans = SplitToPhones(trans_model, alignment, &split_alignment);
  if (!ans) {
    KALDI_WARN << "AccumulateTreeStats: alignment appears to be bad, not using it";
    return;
  }

  int32 cur_pos = 0;
  # dim
  int32 dim = features.NumCols();
  # utt 内 帧数--特征序列数   == 对齐得到的trans-ids 序列数
  KALDI_ASSERT(features.NumRows() == static_cast<int32>(alignment.size()));
  
  # 每个分割好的音素.
  for (int32 i = -info.context_width; i < static_cast<int32>(split_alignment.size()); i++) {
    // consider window starting at i, only if i+info.central_position is within list of phones.

    if (i + info.central_position >= 0 &&
        i + info.central_position < static_cast<int32>(split_alignment.size())) {

      # 获得中心音素
      int32 central_phone = MapPhone(
                      # 音素映射map
                      info.phone_map,  
                      # 对应的中心音素
                      trans_model.TransitionIdToPhone(split_alignment[i+info.central_position][0]));
                      
      # 确定是否独立音素.
      bool is_ctx_dep = !std::binary_search(info.ci_phones.begin(),
                                            info.ci_phones.end(),
                                            central_phone);

      EventType evec;
      # 音素窗内某个音素
      for (int32 j = 0; j < info.context_width; j++) {
        int32 phone;
        if (i + j >= 0 && i + j < static_cast<int32>(split_alignment.size()))
          # 音素窗内 三个音素
          phone =
              MapPhone(info.phone_map,
                       trans_model.TransitionIdToPhone(split_alignment[i+j][0]));
        else
          # ContextDependency class uses 0 to mean "out of window";
          phone = 0;  
        // we also set the phone arbitrarily to 0

        // Don't add stuff to the event that we don't "allow" to be asked, due
        // to the central phone being context-independent: check "is_ctx_dep".
        // Why not just set the value to zero in this
        // case?  It's for safety.  By omitting the key from the event, we
        // ensure that there is no way a question can ever be asked that might
        // give an inconsistent answer in tree-training versus graph-building.
        // [setting it to zero would have the same effect given the "normal"
        // recipe but might be less robust to changes in tree-building recipe].

        if (is_ctx_dep || j == info.central_position)
          # 将<contex-width-index, phone> 加入 evec
          evec.push_back(std::make_pair(static_cast<EventKeyType>(j), static_cast<EventValueType>(phone)));
      }
      # 某个音素内的所有状态-trans-ids
      for (int32 j = 0; j < static_cast<int32>(split_alignment[i+info.central_position].size());j++) {
        # for central phone of this window...
        EventType evec_more(evec);
        # 获得该状态当前的pdf-class
        int32 pdf_class = trans_model.TransitionIdToPdfClass(
            split_alignment[i+info.central_position][j]);

        # pdf_class will normally by 0, 1 or 2 for 3-state HMM.
        std::pair<EventKeyType, EventValueType> pr(kPdfClass, pdf_class);
        # 将<-1, state> 加入evec
        evec_more.push_back(pr);

        std::sort(evec_more.begin(), evec_more.end());  // these must be sorted!
        # 如果某个对应的HMM状态 的统计为0 构建一个高斯分量.
        if (stats->count(evec_more) == 0)
          (*stats)[evec_more] = new GaussClusterable(dim, info.var_floor);

        # 增加统计
        BaseFloat weight = 1.0;
        (*stats)[evec_more]->AddStats(features.Row(cur_pos), weight);
        cur_pos++;
      }
    }
  }
  KALDI_ASSERT(cur_pos == static_cast<int32>(alignment.size()));
}


* sum-tree-stats

int main(int argc, char *argv[]) {
  using namespace kaldi;
  typedef kaldi::int32 int32;
  try {
    const char *usage =
        "Sum statistics for phonetic-context tree building.\n"
        "Usage:  sum-tree-stats [options] tree-accs-out tree-accs-in1 tree-accs-in2 ...\n"
        "e.g.: \n"
        # 输入     决策树统计量  
        " sum-tree-stats treeacc 1.treeacc 2.treeacc 3.treeacc\n";

    ParseOptions po(usage);
    bool binary = true;

    po.Register("binary", &binary, "Write output in binary mode");
    po.Read(argc, argv);

    if (po.NumArgs() < 2) {
      po.PrintUsage();
      exit(1);
    }

    # 决策树统计量
    std::map<EventType, Clusterable*> tree_stats;
    # 综合统计量writer
    std::string tree_stats_wxfilename = po.GetArg(1);

    // A reminder on what BuildTreeStatsType is:
    // typedef std::vector<std::pair<EventType, Clusterable*> > BuildTreeStatsType;
    
    for (int32 arg = 2; arg <= po.NumArgs(); arg++) {
      std::string tree_stats_rxfilename = po.GetArg(arg);
      bool binary_in;
      Input ki(tree_stats_rxfilename, &binary_in);
      BuildTreeStatsType stats_array;
      GaussClusterable example; // Lets ReadBuildTreeStats know which type to read..
      ReadBuildTreeStats(ki.Stream(), binary_in, example, &stats_array);
      for (BuildTreeStatsType::iterator iter = stats_array.begin();
           iter != stats_array.end(); ++iter) {
        EventType e = iter->first;
        Clusterable *c = iter->second;
        std::map<EventType, Clusterable*>::iterator map_iter = tree_stats.find(e);
        if (map_iter == tree_stats.end()) { // Not already present.
          tree_stats[e] = c;
        } else {
          map_iter->second->Add(*c);
          delete c;
        }
      }
    }

    BuildTreeStatsType stats;  // vectorized form.

    for (std::map<EventType, Clusterable*>::const_iterator iter = tree_stats.begin();  
        iter != tree_stats.end();
         ++iter) {
      stats.push_back(std::make_pair(iter->first, iter->second));
    }
    tree_stats.clear();

    {
      Output ko(tree_stats_wxfilename, binary);
      WriteBuildTreeStats(ko.Stream(), binary, stats);
    }
    KALDI_LOG << "Wrote summed accs ( " << stats.size() << " individual stats)";
    DeleteBuildTreeStats(&stats);
    return (stats.size() != 0 ? 0 : 1);
  } catch(const std::exception &e) {
    std::cerr << e.what();
    return -1;
  }
}

  


* 
 EventMap
 
