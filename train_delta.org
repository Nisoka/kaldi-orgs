
steps/train_deltas.sh --boost-silence 1.25 --cmd "$train_cmd" \
2000 10000 data/mfcc/train data/lang exp/mono_ali exp/tri1 || exit 1;

# 决策树叶节点总数 2000 绑定状态数
numleaves = $1 
# 高斯总数   平均每个状态5个混合数??? 编译后看看
totgauss=$2
# mfcc/train/
data=$3
# lang/ 拓扑结构、发音词典、其他发音、所有词words.txt
lang=$4
# mono_ali 已对齐的单音素训练结果.
alidir=$5
# tri1 三音素结果 输出目录
dir=$6


acc-tree-stats --ci-phones=$ciphonelist $alidir/final.mdl "$feats" "ark:gunzip -c $alidir/ali.JOB.gz|" $dir/JOB.treeacc || exit 1;

sum-tree-stats $dir/treeacc $dir/*.treeacc 2>$dir/log/sum_tree_acc.log || exit 1;


* acc-tree-stats
  # 统计 训练决策数需要的统计量
  # input 特征 对齐的状态序列 HMM-GMM模型
  # outpu 决策数统计量
  # Context width 和 central position用来识别上下文环境
  # 转移模型 用来获得pdf-id 和 音素.
  /** @brief Accumulate tree statistics for decision tree training. The
program reads in a feature archive, and the corresponding alignments,
and generates the sufficient statistics for the decision tree
creation. Context width and central phone position are used to
identify the contexts.Transition model is used as an input to identify
the PDF's and the phones.  */

int main(int argc, char *argv[]) {
    const char *usage =
        "Accumulate statistics for phonetic-context tree building.\n"
        "Usage:  acc-tree-stats [options] <model-in> <features-rspecifier> <alignments-rspecifier> <tree-accs-out>\n"
        "e.g.: \n"

        # 输入 HMM-GMM模型   特征  对齐的状态序列   
        # 输出 计算统计量
        " acc-tree-stats 1.mdl scp:train.scp ark:1.ali 1.tacc\n";

    bool binary = true;
    # 计算 决策树需要的 统计信息 选项. 
    # Context-width = 3 central postion = 1, 标准三音素窗。
    AccumulateTreeStatsOptions opts;

    std::string
    model_filename = po.GetArg(1),
    feature_rspecifier = po.GetArg(2),
    # 对齐状态序列
    alignment_rspecifier = po.GetArg(3),
    accs_out_wxfilename = po.GetOptArg(4);

    # 统计 决策树统计信息
    AccumulateTreeStatsInfo acc_tree_stats_info(opts);

    # 转移模型
    TransitionModel trans_model;
    {
      bool binary;
      Input ki(model_filename, &binary);
      trans_model.Read(ki.Stream(), binary);
    }

    # 特征reader
    SequentialBaseFloatMatrixReader feature_reader(feature_rspecifier);
    # 对齐状态reader
    RandomAccessInt32VectorReader alignment_reader(alignment_rspecifier);

    # 绑定树 用的统计量 
    # EventType -- <三音素, 状态>  某个确定状态
    # GaussClusterable  该状态对应的特征向量个数、特征向量累加、特征向量平方和累加.
    std::map<EventType, GaussClusterable*> tree_stats;
    int num_done = 0, num_no_alignment = 0, num_other_error = 0;
    # foreach utt
    for (; !feature_reader.Done(); feature_reader.Next()) {
      # utt feature
      std::string key = feature_reader.Key();
      # align states
      if (!alignment_reader.HasKey(key)) {
        num_no_alignment++;
      } else {
        # utt feature is mat (frame X 39)
        const Matrix<BaseFloat> &mat = feature_reader.Value();
        # vector<trans-ids>  对齐的转移id
        const std::vector<int32> &alignment = alignment_reader.Value(key);
        
        if (alignment.size() != mat.NumRows()) {
          KALDI_WARN << "Alignments has wrong size "<< (alignment.size())<<" vs. "<< (mat.NumRows());
          num_other_error++;
          continue;
        }

        # 根据统计模型、对齐的trans-ids、特征mat 以及统计用参数, 
        # 计算统计信息  --- > tree_stats
        AccumulateTreeStats(trans_model,
                            acc_tree_stats_info,
                            alignment,
                            mat,
                            &tree_stats);
        num_done++;
        if (num_done % 1000 == 0)
          KALDI_LOG << "Processed " << num_done << " utterances.";
      }
    }

    
    BuildTreeStatsType stats;  // vectorized form.

    # foreach state-stats？？？ 保存的和 刚刚计算没什么区别, 可能这里更好使用吧.
    for (std::map<EventType, GaussClusterable*>::const_iterator iter = tree_stats.begin();
         iter != tree_stats.end();
         ++iter) {
      
      stats.push_back(std::make_pair(iter->first, iter->second));
    }
    tree_stats.clear();
    
    # write 统计信息
    {
      Output ko(accs_out_wxfilename, binary);
      WriteBuildTreeStats(ko.Stream(), binary, stats);
    }

    DeleteBuildTreeStats(&stats);
}


**  AccumulateTreeStats 计算决策树构建需要的统计量

void AccumulateTreeStats(const TransitionModel &trans_model,
                         const AccumulateTreeStatsInfo &info,
                         const std::vector<int32> &alignment,
                         const Matrix<BaseFloat> &features,
                         std::map<EventType, GaussClusterable*> *stats) {

  std::vector<std::vector<int32> > split_alignment;
  # SplitToPhones 将utt 对齐trans-ids 根据对应的音素 进行split划分, 
  # 划分得到多个 Vector<音素- vector<状态id> > 
  # 将trans-ids 转化为 以phone为分割的 状态序列. 
  bool ans = SplitToPhones(trans_model, alignment, &split_alignment);
  int32 cur_pos = 0;
  # 每个分割好的音素. context_width = 3 , central_postion = 1 
  for (int32 i = -info.context_width; i < static_cast<int32>(split_alignment.size()); i++) {
    // consider window starting at i, only if i+info.central_position is within list of phones.
    # 形成三音素上下文环境
    if (i + info.central_position >= 0 &&
        i + info.central_position < static_cast<int32>(split_alignment.size())) {

      # 获得中心音素
      int32 central_phone = MapPhone(
                      # 音素映射map
                      info.phone_map,  
                      # 对应的中心音素
                      trans_model.TransitionIdToPhone(split_alignment[i+info.central_position][0]));
                      
      # 确定是否独立音素.
      bool is_ctx_dep = !std::binary_search(info.ci_phones.begin(),
                                            info.ci_phones.end(),
                                            central_phone);
      EventType evec;
      # 音素窗内某个音素
      for (int32 j = 0; j < info.context_width; j++) {
        int32 phone;
        if (i + j >= 0 && i + j < static_cast<int32>(split_alignment.size()))
          # 音素窗内 三个音素
          phone =
              MapPhone(info.phone_map,
                       trans_model.TransitionIdToPhone(split_alignment[i+j][0]));
        else
          # ContextDependency class uses 0 to mean "out of window";
          phone = 0;  
        // we also set the phone arbitrarily to 0

        if (is_ctx_dep || j == info.central_position)
          # 将<contex-width-index, phone> 加入 evec  获得可查找的音素位置.
          evec.push_back(std::make_pair(static_cast<EventKeyType>(j), static_cast<EventValueType>(phone)));
      }
      # 某个音素内的所有状态-trans-ids
      for (int32 j = 0; j < static_cast<int32>(split_alignment[i+info.central_position].size());j++) {
        # for central phone of this window...
        EventType evec_more(evec);
        # 获得该状态当前的pdf-class
        int32 pdf_class = trans_model.TransitionIdToPdfClass(
            split_alignment[i+info.central_position][j]);

        # pdf_class will normally by 0, 1 or 2 for 3-state HMM.
        std::pair<EventKeyType, EventValueType> pr(kPdfClass, pdf_class);
        # 将<-1, state> 加入evec
        evec_more.push_back(pr);

        std::sort(evec_more.begin(), evec_more.end());  // these must be sorted!
        # 如果某个三音素的HMM状态 构建统计量.
        if (stats->count(evec_more) == 0)
          (*stats)[evec_more] = new GaussClusterable(dim, info.var_floor);

        # 增加统计
        BaseFloat weight = 1.0;
        (*stats)[evec_more]->AddStats(features.Row(cur_pos), weight);
        cur_pos++;
      }
    }
  }
  KALDI_ASSERT(cur_pos == static_cast<int32>(alignment.size()));
}


** SplitToPhonesInternal 转化到音素序列
   static bool kaldi::SplitToPhonesInternal ( const TransitionModel &  trans_model,
                                              const std::vector< int32 > &  alignment,
                                              bool  reordered,
                                              std::vector< std::vector< int32 > > *  split_output 
                                              ) 

  618   std::vector<size_t> end_points;  // points at which phones end [in an
  619   // stl iterator sense, i.e. actually one past the last transition-id within
  620   // each phone]..

  622   bool was_ok = true;
        # foreach 每帧状态
  623   for (size_t i = 0; i < alignment.size(); i++) {
  624     int32 trans_id = alignment[i];
          # 正常音素分割点
  625     if (trans_model.IsFinal(trans_id)) {  // is final-prob
  626       if (!reordered) end_points.push_back(i+1);
  627       else {  // reordered.
  628         while (i+1 < alignment.size() &&
  629               trans_model.IsSelfLoop(alignment[i+1])) {
  630           KALDI_ASSERT(trans_model.TransitionIdToTransitionState(alignment[i]) ==
  631                  trans_model.TransitionIdToTransitionState(alignment[i+1]));
  632           i++;
  633         }
  634         end_points.push_back(i+1);
  635       }
          # 错误情况
  636     } else if (i+1 == alignment.size()) {
  637       // need to have an end-point at the actual end.
  638       // but this is an error- should have been detected already.
  639       was_ok = false;
  640       end_points.push_back(i+1);
          # 状态判断
  641     } else {
  642       int32 this_state = trans_model.TransitionIdToTransitionState(alignment[i]),
  643           next_state = trans_model.TransitionIdToTransitionState(alignment[i+1]);
  644       if (this_state == next_state) continue;  // optimization.
  645       int32 this_phone = trans_model.TransitionStateToPhone(this_state),
  646           next_phone = trans_model.TransitionStateToPhone(next_state);
  647       if (this_phone != next_phone) {
  650         was_ok = false;
  651         end_points.push_back(i+1);
  652       }
  653     }
  654   }
        # 将属于各自音素的状态 划归到音素队列中，形成 <音素 <状态>> 的结构
  656   size_t cur_point = 0;
  657   for (size_t i = 0; i < end_points.size(); i++) {
  658     split_output->push_back(std::vector<int32>());
  662     int32 trans_state =
  663       trans_model.TransitionIdToTransitionState(alignment[cur_point]);
  664     int32 phone = trans_model.TransitionStateToPhone(trans_state);
  665     int32 forward_pdf_class = trans_model.GetTopo().TopologyForPhone(phone)[0].forward_pdf_class;
  666     if (forward_pdf_class != kNoPdf)  // initial-state of the current phone is emitting
  667       if (trans_model.TransitionStateToHmmState(trans_state) != 0)
  668         was_ok = false;
          # 划归状态到音素操作
  669     for (size_t j = cur_point; j < end_points[i]; j++)
  670       split_output->back().push_back(alignment[j]);
  671     cur_point = end_points[i];
  672   }
  673   return was_ok;
  674 }


* sum-tree-stats

int main(int argc, char *argv[]) {
  using namespace kaldi;
  typedef kaldi::int32 int32;
  try {
    const char *usage =
        "Sum statistics for phonetic-context tree building.\n"
        "Usage:  sum-tree-stats [options] tree-accs-out tree-accs-in1 tree-accs-in2 ...\n"
        "e.g.: \n"
        # 输入     决策树统计量  
        " sum-tree-stats treeacc 1.treeacc 2.treeacc 3.treeacc\n";

    ParseOptions po(usage);
    bool binary = true;


    # 统计量
    std::map<EventType, Clusterable*> tree_stats;
    # 统计量writer
    std::string tree_stats_wxfilename = po.GetArg(1);

    // A reminder on what BuildTreeStatsType is:
    // typedef std::vector<std::pair<EventType, Clusterable*> > BuildTreeStatsType;
    
    for (int32 arg = 2; arg <= po.NumArgs(); arg++) {
      std::string tree_stats_rxfilename = po.GetArg(arg);
      bool binary_in;
      Input ki(tree_stats_rxfilename, &binary_in);
      BuildTreeStatsType stats_array;
      GaussClusterable example; // Lets ReadBuildTreeStats know which type to read..
      ReadBuildTreeStats(ki.Stream(), binary_in, example, &stats_array);
      for (BuildTreeStatsType::iterator iter = stats_array.begin();
           iter != stats_array.end(); ++iter) {
        EventType e = iter->first;
        Clusterable *c = iter->second;
        std::map<EventType, Clusterable*>::iterator map_iter = tree_stats.find(e);
        if (map_iter == tree_stats.end()) { // Not already present.
          tree_stats[e] = c;
        } else {
          map_iter->second->Add(*c);
          delete c;
        }
      }
    }

    BuildTreeStatsType stats;  // vectorized form.

    for (std::map<EventType, Clusterable*>::const_iterator iter = tree_stats.begin();  
        iter != tree_stats.end();
         ++iter) {
      stats.push_back(std::make_pair(iter->first, iter->second));
    }
    tree_stats.clear();

    {
      Output ko(tree_stats_wxfilename, binary);
      WriteBuildTreeStats(ko.Stream(), binary, stats);
    }
    KALDI_LOG << "Wrote summed accs ( " << stats.size() << " individual stats)";
    DeleteBuildTreeStats(&stats);
    return (stats.size() != 0 ? 0 : 1);
  } catch(const std::exception &e) {
    std::cerr << e.what();
    return -1;
  }
}

  


* 
 EventMap
 
